var K=Object.defineProperty;var H=(a,t,e)=>t in a?K(a,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):a[t]=e;var u=(a,t,e)=>H(a,typeof t!="symbol"?t+"":t,e);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))n(s);new MutationObserver(s=>{for(const o of s)if(o.type==="childList")for(const i of o.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&n(i)}).observe(document,{childList:!0,subtree:!0});function e(s){const o={};return s.integrity&&(o.integrity=s.integrity),s.referrerPolicy&&(o.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?o.credentials="include":s.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function n(s){if(s.ep)return;s.ep=!0;const o=e(s);fetch(s.href,o)}})();const X=1;class l{constructor(t,e,n=[],s=0){u(this,"type");u(this,"attrs");u(this,"content");u(this,"startOffset");u(this,"endOffset");this.type=t,this.attrs=e,this.content=n,this.startOffset=s,this.endOffset=this.calculateEndOffset()}static isTSENode(t){return t instanceof l&&typeof t.type=="string"&&Array.isArray(t.content)}calculateEndOffset(){let t=this.startOffset;return this.content.forEach(e=>{e instanceof l?t=Math.max(t,e.calculateEndOffset()):typeof e=="string"&&(t+=e.length)}),t}recalculateOffsets(){const t=(e,n,s=!1)=>{e.startOffset=n;let o=n,i=0;e.content.length-1;for(let r=0;r<e.content.length;r++){const c=e.content[r];i=r,typeof c=="string"?o+=c.length:c instanceof l&&(o=t(c,o))}return e.endOffset=o,e.type==="paragraph"&&!s&&(o+=X),o};t(this,0,!0)}toJSON(){return{type:this.type,attrs:this.attrs,content:this.content.map(t=>t instanceof l?t.toJSON():t)}}update(t,e=this.content){return new l(this.type,t||this.attrs,e)}getNodeLength(){return typeof this=="string"?this.length:this instanceof l?this.content.reduce((t,e)=>typeof e=="string"?t+e.length:e instanceof l?t+e.getNodeLength():t,0):0}}class M{constructor(t){u(this,"node");u(this,"dom");u(this,"selected");this.node=t,this.dom=this.createDOM(),this.selected=!1,this.addEventListeners()}createDOM(){let t;return this.node.type==="paragraph"?t=document.createElement("p"):this.node.type==="heading"?t=document.createElement(`h${this.node.attrs.level||1}`):this.node.type==="bold"?t=document.createElement("b"):this.node.type==="italic"?t=document.createElement("i"):this.node.type==="ul"?t=document.createElement("ul"):this.node.type==="li"?t=document.createElement("li"):t=document.createElement("div"),this.updateAttributes(t),this.updateContent(t),t}updateAttributes(t){this.node.attrs&&Object.entries(this.node.attrs).forEach(([e,n])=>{n?t.setAttribute(e,n):t.removeAttribute(e)})}updateContent(t){this.node.content.forEach(e=>{if(typeof e=="string")t.appendChild(document.createTextNode(e));else if(e instanceof l){const n=new M(e);t.appendChild(n.dom)}})}update(t){if(t.type!==this.node.type)return!1;this.node=t,this.updateAttributes(this.dom);const e=t.content.join("");return this.dom.textContent!==e&&this.updateContent(this.dom),!0}selectNode(){this.selected=!0,this.dom.classList.add("selected-node"),this.dom.style.outline="1px solid gray",setTimeout(()=>{this.deselectNode()},500)}deselectNode(){this.selected=!1,this.dom.classList.remove("selected-node"),this.dom.style.outline=""}onClick(t){this.selected?this.deselectNode():this.selectNode()}addEventListeners(){this.dom.addEventListener("click",this.onClick.bind(this))}removeEventListeners(){this.dom.removeEventListener("click",this.onClick.bind(this))}destroy(){this.removeEventListeners(),this.dom.remove()}ignoreMutation(t){return t.type!=="characterData"}addClass(t){this.dom.classList.add(t)}removeClass(t){this.dom.classList.remove(t)}}const I=1,q="tse";function $(a,t){var o,i;const e=document.getElementById(q);let n=a,s=t;for(;n&&n.previousSibling;){n=n.previousSibling;const r=n.nodeType===Node.ELEMENT_NODE,c=n.nodeType===Node.TEXT_NODE;if(r){const f=n;f.nodeName==="P"?(s+=((o=f.textContent)==null?void 0:o.length)||0,s+=I):s+=((i=f.textContent)==null?void 0:i.length)||0}else c&&(s+=n.length)}return n!=null&&n.parentNode&&n.parentNode!==e?s+$(n.parentNode,0):s}function v(a,t,e){const n=window.getSelection();if(!n||!e.rootElement){console.warn("Unable to update selection.");return}const s=e.state.getWindowOffsetFrom(a,t,e.rootElement);if(!s)throw new Error("windowOffset범위를 찾지 못했습니다.");const{windowStartOffset:o,windowEndOffset:i}=s,r=e.state.getWindowNodeFrom(a,t,e.rootElement),{node:c,content:f,contentIndex:d}=e.state.getNodeContentFrom(a,t),h=document.createRange();return{selection:n,windowStartOffset:o,windowEndOffset:i,windowNode:r,range:h,tseNode:c,content:f,contentIndex:d}}class k{constructor(t){u(this,"rootNode");u(this,"startOffset",0);u(this,"endOffset",0);u(this,"matchedNode",null);this.rootNode=t}updateRootNode(t){this.rootNode=t}updateSelection(){var o,i,r,c,f,d,h;const t=window.getSelection();if(!(t!=null&&t.rangeCount))return;const e=t.getRangeAt(0);this.startOffset=$(e.startContainer,e.startOffset),this.endOffset=$(e.endContainer,e.endOffset),this.matchedNode=this.findNodeByOffset(this.rootNode,this.startOffset);const n=document.getElementById("output"),s=typeof((o=this.matchedNode)==null?void 0:o.content)=="string"?this.matchedNode.content:(r=(i=this.matchedNode)==null?void 0:i.content)==null?void 0:r.join("");this.startOffset===this.endOffset?n&&(n.innerText=`stateOffset: ${this.startOffset}, 
 노드 내용: "${s}", 
 노드 범위: "${(c=this.matchedNode)==null?void 0:c.startOffset} ~ ${(f=this.matchedNode)==null?void 0:f.endOffset}"
 현재 노드 컨텐츠: ${JSON.stringify(this.rootNode.content,null,2)}`):n&&(n.textContent=`선택 범위: ${this.startOffset} ~ ${this.endOffset}, 노드 내용: "${s}", 노드 범위: "${(d=this.matchedNode)==null?void 0:d.startOffset} ~ ${(h=this.matchedNode)==null?void 0:h.endOffset}"`)}findNodeByOffset(t,e){if(typeof t=="string")return null;if(e>=t.startOffset&&e<=t.endOffset){if(typeof t.content=="string")return t;if(Array.isArray(t.content))for(const n of t.content){const s=this.findNodeByOffset(n,e);if(s)return s}return t}return null}}class Z{constructor(t,e,n){u(this,"state");u(this,"rootElement");u(this,"selection");u(this,"plugins");this.rootElement=t,this.state=e,this.selection=new k(this.state.doc),this.plugins=n,this.initialRender(),this.addEventListeners(),this.initializePlugins()}initializePlugins(){this.plugins.forEach(t=>{var e;return(e=t.onInit)==null?void 0:e.call(t,this)})}dispatch(t,e){this.state=this.state.apply(t),this.state.selection=this.selection,this.state.selection.updateRootNode(this.state.doc),this.state.selection.updateSelection(),this.syncDOM(t),e&&e.afterSyncDOM&&e.afterSyncDOM(t,this)}updateDOM(t,e){for(let n=t;n<e;n++){const s=this.state.doc.content[n],o=this.rootElement.childNodes[n];if(typeof s=="string"){const i=document.createTextNode(s);o?o.nodeType===Node.TEXT_NODE?o.textContent=s:this.rootElement.replaceChild(i,o):this.rootElement.appendChild(i)}else if(s instanceof l){const i=new M(s);o?this.rootElement.replaceChild(i.dom,o):this.rootElement.appendChild(i.dom)}}}removeUselessDOM(){for(;this.rootElement.childNodes.length>this.state.doc.content.length;)this.rootElement.removeChild(this.rootElement.childNodes[this.state.doc.content.length])}syncDOM(t){if(t.changedRange){const{from:e,to:n}=t.changedRange;this.updateDOM(e,n),this.removeUselessDOM()}}initialRender(){this.rootElement.innerHTML="",this.rootElement.setAttribute("contentEditable","true"),this.state.doc.content.forEach(t=>{if(t instanceof l){const e=new M(t);this.rootElement.appendChild(e.dom)}else if(typeof t=="string"){const e=document.createTextNode(t);this.rootElement.appendChild(e)}})}addEventListeners(){this.plugins.forEach(t=>{this.rootElement.addEventListener(t.eventType,e=>{e.preventDefault(),t.on(e,this)})})}}class B{constructor(t,e){u(this,"schema");u(this,"doc");u(this,"selection");this.schema=t.schema,this.doc=t.doc||this.schema.createNode("doc",{},[]),this.selection=e}apply(t){let e=this.doc;return t.steps.forEach(n=>{e=n(e)}),e.recalculateOffsets(),this.doc,new B({schema:this.schema,doc:e},this.selection)}validateRange(t,e){if(t<this.doc.startOffset||e>this.doc.endOffset)throw new Error(`범위에 맞지 않은 노드 탐색입니다, ${this.doc.type}, ${t} ${e}`)}getNodeFrom(t,e){this.validateRange(t,e);const n=o=>{if(o.startOffset<=t&&o.endOffset>=e){const r=o.content;for(let c=0;c<r.length;c++){const f=r[c];if(f instanceof l){const d=n(f);if(d)return d}}return o}return null},s=n(this.doc);if(!s)throw new Error("TSENode찾기에 실패하였습니다. 범위를 확인해주세요");return s}getNodeContentFrom(t,e){this.validateRange(t,e);const n=o=>{if(!(o.startOffset<=t&&o.endOffset>=e))return null;const r=o.content;let c=o.startOffset,f;for(let d=0;d<r.length;d++){const h=r[d];typeof h=="string"?f=h.length:f=h.endOffset-h.startOffset+I;const O=c,m=c+f;if(O<=t&&m>=e)if(h instanceof l){const p=n(h);if(p)return p}else return{node:o,contentIndex:d,content:h};c+=f}return null},s=n(this.doc);if(!s)throw new Error("해당 범위에 해당하는 content를 찾을 수 없습니다. 범위를 확인해주세요.");return s}getWindowNodeFrom(t,e,n){const s=this.doc,o=(r,c,f,d)=>{if(d<r.startOffset||f>r.endOffset)return null;let h=0;for(let m=0;m<r.content.length;m++){const g=r.content[m];if(typeof g=="string"){const p=g;p.length,r.startOffset+(g===r.content[0]?0:p===g?p.length:0)}}let O=r.startOffset;for(let m=0;m<r.content.length;m++){const g=r.content[m],p=c.childNodes[h];if(typeof g=="string"){const E=g.length,w=O,y=O+E-1;if(w<=d&&y>=f)return c.nodeType===Node.ELEMENT_NODE?c:p;O+=E,h++}else if(g instanceof l){const E=g.startOffset,w=g.endOffset;if(w>=f&&E<=d){const y=o(g,p,f,d);if(y)return y}O=w+1,h++}}return r.startOffset<=d&&r.endOffset>=f&&c.nodeType===Node.ELEMENT_NODE?c:null},i=o(s,n,t,e);if(!i)throw new Error("실제 DOM에서 찾을 수 없는 offset 범위입니다.");return i}getWindowOffsetFrom(t,e,n){this.validateRange(t,e);const s=(i,r,c,f)=>{if(f<i.startOffset||c>i.endOffset)return null;const d=Math.max(c-i.startOffset,0),h=Math.min(f-i.startOffset,i.endOffset-i.startOffset);let O=0;const m=Array.from(r.childNodes);for(let g=0;g<i.content.length;g++){const p=i.content[g],E=m[g];if(typeof p=="string"){const w=p.length,y=O,N=O+w;if(y<=h&&N>=d){const C=Math.max(d-y,0),S=Math.min(h-y,w);return{windowStartOffset:C,windowEndOffset:S}}O+=w}else if(p instanceof l){const w=s(p,E,c,f);if(w)return w;O+=p.endOffset-p.startOffset}}return d===h?{windowStartOffset:d,windowEndOffset:h}:null},o=s(this.doc,n,t,e);if(!o)throw new Error(`범위를 벗어난 offset입니다. startOffset:${t}, endOffset:${e}`);return o}getSiblingContentFrom(t,e){this.validateRange(t,e);const n=o=>{if(!(o.startOffset<=t&&o.endOffset>=e))return null;const r=o.content;let c=o.startOffset,f;for(let d=0;d<r.length;d++){const h=r[d];typeof h=="string"?f=h.length:f=h.endOffset-h.startOffset+I;const O=c,m=c+f;if(O<=t&&m>=e)if(h instanceof l){const p=n(h);if(p)return p}else return{node:o,contents:r};c+=f}return null},s=n(this.doc);if(!s)throw new Error("해당 범위에 해당하는 content를 찾을 수 없습니다. 범위를 확인해주세요.");return s.contents}getParagraphIdxFrom(t,e){this.validateRange(t,e);const s=(o=>{const i=o.content;for(let r=0;r<i.length;r++){const c=i[r];if(c.startOffset<=t&&c.endOffset>=e)return r}return null})(this.doc);if(s===null)throw new Error("Paragraph Index 찾기에 실패하였습니다. 범위를 확인해주세요");return s}toJSON(){return{schema:this.schema.spec,doc:this.doc.toJSON(),selection:this.selection}}}class G{constructor(t){u(this,"spec");u(this,"nodes");this.spec=t,this.nodes=this.compileNodes(t.nodes)}compileNodes(t){const e={};for(const[n,s]of Object.entries(t))e[n]=s;return e}createNode(t,e,n=[]){if(!this.nodes[t])throw new Error(`Undefined node type: ${t}`);return new l(t,e,n)}nodeFromJSON(t){const{type:e,attrs:n,content:s}=t;return new l(e,n,Array.isArray(s)?s.map(o=>typeof o=="object"&&o!==null?this.nodeFromJSON(o):o):s)}}class T{constructor(t){u(this,"steps",[]);u(this,"changedRange",null);u(this,"state");u(this,"startOffset",null);u(this,"endOffset",null);this.state=t,this.startOffset=this.state.selection.startOffset,this.endOffset=this.state.selection.endOffset}updateChangedRange(t,e){this.changedRange?this.changedRange={from:Math.min(this.changedRange.from,t),to:Math.max(this.changedRange.to,e)}:this.changedRange={from:t,to:e}}modifyTransactionOffset(t,e){this.startOffset=t,this.endOffset=e}addNode(t,e,n=[],s){const o=this.state.schema.createNode(t,e,n);return this.steps.push(i=>{let r=i.content;if(s){const c=i.content.slice(0,s+1),f=i.content.slice(s+1);r=[...c,o,...f],this.updateChangedRange(i.content.length,i.content.length+1)}else r=[...i.content,o],this.updateChangedRange(i.content.length,i.content.length+1);return new l(i.type,i.attrs,r)}),this}updateNodeAttrs(t,e){return this.steps.push(n=>{const s=n.content.map((o,i)=>i===t&&o instanceof l?new l(o.type,{...e},o.content,o.startOffset):o);return this.updateChangedRange(t,t+1),new l(n.type,n.attrs,s)}),this}updateNode(t){return this.steps.push(e=>{const n=r=>{if(r===t)return new l(r.type,r.attrs,t.content,r.startOffset);const c=r.content.map(f=>f instanceof l?n(f):f);return new l(r.type,r.attrs,c,r.startOffset)},s=n(e),o=t.startOffset,i=t.startOffset+t.content.reduce((r,c)=>typeof c=="string"?r+c.length:c instanceof l?r+c.endOffset-c.startOffset+I:r,0);return this.updateChangedRange(o,i),s}),this}}const x={insertText:a=>a+1,deleteText:a=>a-1,enterText:a=>0};function Q(a,t,e){const n=v(a,t,e);if(!n)throw new Error("범위를 찾을 수 없습니다.");const{selection:s,windowStartOffset:o,windowEndOffset:i,windowNode:r,range:c,contentIndex:f}=n,d=r.childNodes[f];c.setStart(d,x.deleteText(o)),c.setEnd(d,x.deleteText(i)),s.removeAllRanges(),s.addRange(c)}function Y(a,t){const{startOffset:e,endOffset:n}=t.selection,s=t.state.getNodeFrom(e,n),{content:o,contentIndex:i}=t.state.getNodeContentFrom(e,n),r=t.state.getWindowOffsetFrom(e,n,t.rootElement);if(!r)throw new Error("windowOffset범위를 찾지 못했습니다.");const{windowStartOffset:c,windowEndOffset:f}=r,d=new T(t.state);if(typeof o=="string"){const h=o.slice(0,c-1)+o.slice(f);s.content[i]=h}else throw new Error("문자가 아닌 node가 탐색 되었습니다.");return d.updateNode(s),d}class _{constructor(){u(this,"eventType","input")}on(t,e){const n=t;if(n.inputType==="deleteContentBackward"){const s=Y(n.data||"",e);e.dispatch(s,this)}}afterSyncDOM(t,e){Q(t.startOffset||0,t.endOffset||0,e)}}function tt(a,t,e){const n=v(a,t,e);if(!n)throw new Error("범위를 찾을 수 없습니다.");const{selection:s,windowStartOffset:o,windowEndOffset:i,windowNode:r,range:c,contentIndex:f}=n,d=r.childNodes[f].parentNode;c.setStart(d,x.enterText(o)),c.setEnd(d,x.enterText(i)),s.removeAllRanges(),s.addRange(c)}function et(a){const{startOffset:t,endOffset:e}=a.selection,n=t-1>0?t-1:0,s=e-1>0?e-1:0,{content:o,contentIndex:i}=a.state.getNodeContentFrom(n,s),r=new T(a.state),c=a.state.getParagraphIdxFrom(n,s),f=a.state.getWindowOffsetFrom(n,s,a.rootElement);if(!f)throw new Error("windowOffset범위를 찾지 못했습니다.");const{windowStartOffset:d,windowEndOffset:h}=f,O=(g,p,E)=>{const w=g.content;for(let y=0;y<w.length;y++){const N=w[y];if(N instanceof l){const C=O(N,g,y);if(C)return C}if(N===o){const C=["bold","italic"],S=["li","ul","ol"],U=(p==null?void 0:p.type)==="paragraph"&&E!==null&&C.includes(g.type),j=S.includes((p==null?void 0:p.type)||"")&&E!==null&&S.includes(g.type),V=(p==null?void 0:p.type)==="doc"&&g.type==="paragraph"&&E!==null;if(U){const P=a.state.doc.content.slice(0,c),R=a.state.doc.content[c],L=a.state.doc.content.slice(c+1),D=N.slice(0,d),F=N.slice(h),b=new l("paragraph",{},[...R.content.slice(0,E),new l(g.type,{},[D])]),A=new l("paragraph",{},[new l(g.type,{},[F]),...R.content.slice(E+1)]);return a.state.doc.content=[...P,b,A,...L],a.state.doc}else if(V){const P=a.state.doc.content.slice(0,c),R=a.state.doc.content[c],L=a.state.doc.content.slice(c+1),D=N.slice(0,d),F=N.slice(h),b=R.content.slice(0,i),A=R.content.slice(i+1),z=new l("paragraph",{},[...b,D]),J=new l("paragraph",{},[F,...A]);return a.state.doc.content=[...P,z,J,...L],a.state.doc}else j&&console.log("welcome listNode","currentType : ",g.type);return a.state.doc}}return null},m=O(a.state.doc,null,null);if(!m)throw new Error("문단 찾지 못한 에러 같습니다.");return console.log({result:m}),r.updateNode(m),r}class nt{constructor(){u(this,"eventType","keyup")}on(t,e){if(t.key==="Enter"){const s=et(e);e.dispatch(s,this)}}afterSyncDOM(t,e){tt(t.startOffset||0,t.endOffset||0,e)}}function st(a,t,e){const n=v(a,t,e);if(!n)throw new Error("범위를 찾을 수 없습니다.");const{selection:s,windowStartOffset:o,windowEndOffset:i,windowNode:r,range:c,contentIndex:f}=n,d=r.childNodes[f];c.setStart(d,x.insertText(o)),c.setEnd(d,x.insertText(i)),s.removeAllRanges(),s.addRange(c)}function ot(a,t){const{startOffset:e,endOffset:n}=t.selection,s=t.state.getNodeFrom(e,n),{content:o,contentIndex:i}=t.state.getNodeContentFrom(e,n),r=t.state.getWindowOffsetFrom(e,n,t.rootElement);if(!r)throw new Error("windowOffset범위를 찾지 못했습니다.");const{windowStartOffset:c,windowEndOffset:f}=r,d=new T(t.state);if(typeof o=="string"){const h=o.slice(0,c)+a+o.slice(f);s.content[i]=h}else throw new Error("문자가 아닌 node가 탐색 되었습니다.");return d.updateNode(s),d}class rt{constructor(){u(this,"eventType","input")}on(t,e){const n=t;if(n.inputType==="insertText"){const s=ot(n.data||"",e);e.dispatch(s,this)}}afterSyncDOM(t,e){st(t.startOffset||0,t.endOffset||0,e)}}class it{constructor(){u(this,"eventType","keyup")}on(t,e){e.selection.updateSelection()}}class ct{constructor(){u(this,"eventType","mouseup")}on(t,e){e.selection.updateSelection()}}const at=[new rt,new _,new ct,new it,new nt],ft={nodes:{doc:{content:"block+"},paragraph:{group:"block"},heading:{group:"block",attrs:{level:1}}}},dt=new G(ft),W=document.getElementById("tse");if(W){const a=new l("doc",{id:"test"},[new l("paragraph",{},["Hello, World!"]),new l("paragraph",{},["ProseMirror-inspired editor"]),new l("paragraph",{},["Some Text is Start and ",new l("bold",{},["Bold Text"])," and more text"]),new l("paragraph",{},[new l("ul",{},[new l("li",{},["list1"]),new l("li",{},["list2"]),new l("li",{},["list3"])])])]),t=new k(a),e=new B({schema:dt,doc:a},t),n=[...at],s=new Z(W,e,n),o=new T(e);o.addNode("paragraph",{},["This is a new paragraph added with Transaction."]);const i=new T(e);i.addNode("paragraph",{},["Anything is Start and ",new l("italic",{},["Italic Text"])," and more text"]);const r=new T(e);r.addNode("paragraph",{},[""]),s.dispatch(o),s.dispatch(r),s.dispatch(i)}
